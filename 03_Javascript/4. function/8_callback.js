/**
 * callback(콜백 함수) : 함수의 파라미터로 입력되는 익명 함수
 */

// 1. 힙에 생성됨
const job = (a, b, callback) => { // a = 1, b = 2, callback = print 함수 주소값
    callback(a, b);
}

// 2. 힙에 생성됨
const print = (a, b) => { console.log(a, b); }

// 1, 2까지는 실행 단계가 아닌 준비 단계

// 3. stack에 생성됨
job(1, 2, print); // 메모리에서 바로 실행하기에 에러없이 동작하는 동기식


// setTimeout 함수 호출 - 비동기식
// 한 쓰레드 밖에 없기 때문에, 시간이 걸리는 작업(바로 처리할 수 없는 부분들)을 창고에 넣어둠

// window.setTimeout();
// setTimeout은 비동기식 처리를 하므로, 백그라운드에 저장된 후
// 이벤트 루프를 통해 호촐되어 콜스택에서 처리될 때 자신이 포함한
// 콜백 함수를 실행한다.

// setTimeout(); // window는 최상위로 생략 가능 (자바의 object와 동일한 최상위 계층)
// setTimeout(함수호출, 시간); // 시간 부분을 생략 시 바로 실행해주세요.의 뜻
// setTimeout(callback, delay);
// setTimeout(print(1, 2), 1000); // 1000 = 1초, 1초 뒤에 실행해주세요. 의 뜻

// setTimeout(print(1, 2), 1000);
    // 메모리에서 프린트가 사라지기 전에 const 프린트에
    // setTimeout 프린트의 1,2 값을 미리 보내 콘솔창에 한번 표시 후
    // 이후 메모리에 아무것도 없을때 프린트 1, 2의 값이 없어 에러 발생

// setTimeout(callback(처리할 함수형식), delay);
    // 메모리에 있는 함수의 호출이 아닌, 자신이 처리할 함수 형식이 callback 안에 들어가야 함

console.clear;

console.log(`동기식 처리 -----------------> 1`);
console.log(`동기식 처리 -----------------> 2`);

setTimeout(() => {
    console.log(`setTimeout 호출(비동기) ----> #1`);
}, 0);

console.log(`동기식 처리 -----------------> 3`);

setTimeout(() => {
    console.log(`setTimeout 호출(비동기) ----> #2`);
}, 1000);

console.log(`동기식 처리 -----------------> 4`);

// 1. 동기 처리 : 1 > 2 > 3 > 4
// 동기 처리가 모두 종료된 후에 비동기 작업 처리 진행

// 2. 비동기 처리 : #1, #2
// 만약 delay 시간이 #2가 더 짧을 경우 테스크 큐(대기줄)에 #2가 1번째, #1가 2번째로 쌓여
// event loop가 stack 상태 확인 후 stack에 올림

// 콘솔 결과값
// 동기식 처리 -----------------> 1
// 동기식 처리 -----------------> 2
// 동기식 처리 -----------------> 3
// 동기식 처리 -----------------> 4
// setTimeout 호출(비동기) ----> #1
// setTimeout 호출(비동기) ----> #2

// 노드 기반인 리액트도 자바스크립트와 동일하게 v8 엔진으로 동작하고 처리함